Below is the clean modular decomposition of the whole SignalShadow system â€” each part isolated, replaceable, testable, and scalable. No spaghetti. No godâ€‘service.

Iâ€™ll keep it implementationâ€‘oriented, not fluff.

ğŸ§± SignalShadow â€“ Modular Architecture Breakdown

Each module is logically independent and communicates via typed contracts (events / structs), not tight coupling.

1ï¸âƒ£ Auth Execution Module

AuthRunner

Responsibility

Perform login

Detect successful authentication

Hand off authenticated browser context

Inputs

Login URL

Credentials

Auth type (form / token / cookie)

Outputs

Authenticated Playwright context

Raw auth artifacts

Key Functions
runLogin()
detectAuthSuccess()
extractAuthArtifacts()

Replaceable?

âœ… Yes (can swap Playwright, add SSO support later)

2ï¸âƒ£ Auth Session Vault

AuthSessionStore

Responsibility

Persist auth state

Rehydrate sessions

Detect auth drift

Stored Artifacts

Cookies

localStorage

sessionStorage

Auth headers

JWT claims (metadata only)

Outputs

session_id

auth_state_hash

Key Functions
saveSession()
loadSession()
hashAuthState()
compareAuthStates()

Replaceable?

âœ… Yes (DB, Redis, encrypted file store)

3ï¸âƒ£ Network Intelligence Module

NetObserver

Responsibility

Observe ALL network activity

Normalize requests/responses

Feed data downstream

Captures

XHR / Fetch

Navigation requests

GraphQL ops

WebSocket init

Outputs

Normalized network events

Key Functions
onRequest()
onResponse()
normalizeRequest()

Replaceable?

âœ… Yes (pure observer, no business logic)

4ï¸âƒ£ JavaScript Collection Module

JsHarvester

Responsibility

Collect all post-auth JS

Normalize JS for hashing

Store JS snapshots

Inputs

Network responses

Script tags

Outputs

js_bundle_set

js_hash

Key Functions
collectScripts()
normalizeJs()
hashJsBundle()

Replaceable?

âœ… Yes (can add AST parsing later)

5ï¸âƒ£ Route Discovery Module

RouteExtractor

Responsibility

Discover application routes

Score confidence

De-duplicate noise

Sources

JS static analysis

Router manifests

Network navigation

Prefetch hints

Outputs

route_set (with confidence)

Key Functions
extractFromJs()
extractFromNetwork()
scoreRoutes()

Replaceable?

âœ… Yes (framework-specific plugins)

6ï¸âƒ£ Route Probing Module

RouteVerifier

Responsibility

Confirm route existence

Classify auth enforcement

Trigger lazy loads

Inputs

route_set

Outputs

verified_routes

Key Functions
probeRoute()
classifyResponse()

Replaceable?

âœ… Yes (can add crawl depth later)

7ï¸âƒ£ Lazy Load Trigger Module

BehaviorTrigger

Responsibility

Trigger non-destructive behaviors

Coerce hidden network activity

Behaviors

Route navigation

Smart scrolling

Safe UI events

Outputs

additional network intel

Key Functions
triggerScroll()
triggerSafeEvents()

Replaceable?

âœ… Yes (policy-driven)

8ï¸âƒ£ Endpoint Intelligence Module

ApiProfiler

Responsibility

Build endpoint inventory

Classify endpoints

Detect auth misuse

Inputs

Network events

Outputs

endpoint_graph

endpoint_hash

Key Functions
profileEndpoint()
classifyEndpoint()

Replaceable?

âœ… Yes (GraphQL specialization)

9ï¸âƒ£ Auth & Privilege Analyzer

PrivilegeMapper

Responsibility

Map auth state â†’ routes â†’ APIs

Detect privilege anomalies

Outputs

privilege_map

privilege_hash

Key Functions
buildPrivilegeMap()
detectPrivilegeMismatch()

Replaceable?

âœ… Yes (role-aware extensions)

ğŸ”Ÿ Drift Detection Engine

DriftEngine

Responsibility

Compare snapshots over time

Classify drift type

Emit forensic events

Inputs

Previous snapshot

Current snapshot

Outputs

drift_events

Key Functions
diffHashes()
classifyDrift()

Replaceable?

âŒ Core logic â€” but extensible

1ï¸âƒ£1ï¸âƒ£ Risk Scoring & Taxonomy

RiskInjector

Responsibility

Translate findings into RiskSignal taxonomy

Assign severity

Inject into forensic timeline

Outputs

exposures

timeline entries

Key Functions
scoreRisk()
mapToTaxonomy()

Replaceable?

âŒ Core business value

1ï¸âƒ£2ï¸âƒ£ Orchestration Layer

ShadowOrchestrator

Responsibility

Control execution order

Handle retries

Enforce safety policies

Flow Control
Auth â†’ Session â†’ Observe â†’ Harvest â†’ Extract â†’ Probe â†’ Analyze â†’ Diff â†’ Inject

Replaceable?

âŒ This is the spine

ğŸ§© Inter-Module Communication Style
Strong Rule:

âŒ No module reaches into anotherâ€™s internals

Communication via:

Typed events

Immutable snapshots

Hash references

Example:

JsHarvester â†’ emits js_bundle_hash
DriftEngine consumes hash only


This keeps your system sane.

ğŸ§  Why This Modularity Matters

You can ship partial MVP

You can disable aggressive parts

You can sell tiers

You can test modules in isolation

You can replace internals without breaking product




Now here is the FULL â€œFEATURES + HOWâ€‘ITâ€‘WORKSâ€ DOCUMENT you asked for â€” written like a real internal spec, not vibes.

ğŸ›¡ï¸ RiskSignal â€“ Postâ€‘Auth Recon & Drift System
Hard Recon Automation Engine (No AI, No Noise)

Goal: eliminate manual recon work for bug hunters by automatically extracting authenticated attack surface intelligence and tracking behavioral drift over time â€” without storing sensitive payloads or full files.

1ï¸âƒ£ Core Design Principles

Observe, donâ€™t fuzz

Hash everything, store intelligence only

Browser truth > static guessing

Postâ€‘auth > preâ€‘auth

Hunter decides exploitability, system delivers recon

2ï¸âƒ£ What Is Stored vs NOT Stored
âŒ NOT STORED

Full JS files

Full HTML pages

Response bodies

Credentials

Tokens (raw)

âœ… STORED

Cryptographic hashes

Route lists

Endpoint schemas

Auth behavior metadata

Structural diffs

Recon intelligence artifacts

This keeps:

DB small

Legal risk low

Performance high

3ï¸âƒ£ High-Level Execution Flow
User submits domain + auth
â†“
Headless browser logs in
â†“
Network observer records behavior
â†“
JS & routes extracted in-memory
â†“
Artifacts normalized
â†“
Hashes generated
â†“
Diff against last snapshot
â†“
Recon intelligence saved
â†“
Hunter consumes outputs

4ï¸âƒ£ Authentication Intelligence Engine
Feature: Auth Flow Execution

What it does

Logs in using real browser

Supports:

Form auth

Cookie injection

Bearer token

Why it matters

SPA logic only appears post-auth

APIs behave differently after login

Feature: Auth Success Detection

Detected via:

Cookie creation

Authorization headers

Redirect away from login

Auth-only API calls

No DOM guessing. Pure behavior.

Feature: Auth State Fingerprinting

Captured metadata:

Cookie names (not values)
Storage keys
Auth header patterns
JWT claim structure (not token)


Stored as:

auth_state_hash


Drift here = high severity

5ï¸âƒ£ JavaScript Intelligence Engine
Feature: Postâ€‘Auth JS Harvesting

Collected from:

Script tags

Dynamic imports

Network responses

Only JS loaded after authentication is processed.

Feature: JS Normalization

Before hashing:

Strip comments

Remove timestamps

Normalize whitespace

Keep string literals

Stable ordering

Result:

js_bundle_hash

Feature: JSâ€‘Derived Intelligence Extraction

Extracted artifacts:

API paths

Route strings

Feature flags

Role checks

Disabled features

Conditional logic hints

Saved as:

js_intel {
  routes[]
  api_refs[]
  feature_flags[]
}

6ï¸âƒ£ Route Discovery Engine
Feature: Passive Route Extraction

Routes discovered from:

JS bundle strings

Router manifests

Network navigation

Prefetch hints

Each route gets:

path
source
confidence_score

Feature: Route Verification

Routes are probed safely:

GET only

No mutations

Responses classified:

Response	Meaning
200	Accessible
401	Exists, auth-guarded
403	Exists, role-guarded
302	Exists, redirected
404	Discarded

Saved as:

route_set_hash

7ï¸âƒ£ Lazyâ€‘Loading Coercion System
Feature: Behaviorâ€‘Driven Loading

Triggers:

Direct route navigation

Smart scrolling

Safe UI events

ğŸš« Never:

Submit forms

Delete data

Confirm actions

Trigger payments

This reveals:

Infinite loaders

Background APIs

Featureâ€‘gated data

8ï¸âƒ£ Network & API Intelligence Engine
Feature: Full Network Observation

Captured:

Method

Path

Query structure

Headers (sanitized)

Response schema hash

Stored as:

endpoint_intel {
  method
  path
  auth_type
  schema_hash
}

Feature: Endpoint Classification

Rules-based:

/admin â†’ privileged

/internal â†’ sensitive

/user â†’ user scope

This builds:

endpoint_graph_hash

9ï¸âƒ£ Privilege & Access Mapping
Feature: Privilege Map Generation

Maps:

Auth State â†’ Routes â†’ APIs â†’ Data Access


Produces:

Endpoint	Role	Access
/api/admin/users	user	âŒ
/api/export	user	âš ï¸

Saved as:

privilege_map_hash

ğŸ”Ÿ IDOR & BAC Recon Heuristics (No Exploits)
Detected Patterns:

Admin-looking APIs hit by low roles

Same endpoint across roles

Predictable ID structures

Missing server-side checks

Role mismatch between UI & API

Each adds risk weight, not exploit claim.

1ï¸âƒ£1ï¸âƒ£ Drift Detection Engine (THE CORE VALUE)
Snapshot Hashes Tracked
auth_state_hash
js_bundle_hash
route_set_hash
endpoint_graph_hash
privilege_map_hash

Drift Types
Drift	Meaning
JS changed	New client logic
Routes added	Feature exposure
Endpoint schema changed	Backend change
Auth behavior changed	Security regression
Privilege map changed	BAC risk

Each drift becomes a forensic timeline event.

1ï¸âƒ£2ï¸âƒ£ Recon Artifacts Delivered to Hunter
Feature: Recon Output Sets

You get lists, not alerts:

Authenticated endpoints

Hidden routes

JSâ€‘derived API intent

Privilege mismatches

ID patterns

Drift deltas

Export formats:

JSON

CSV

HARâ€‘like summaries

1ï¸âƒ£3ï¸âƒ£ What This Enables for You (Personally)
Before

Burp + clicking

Miss endpoints

Fatigue

Guesswork

After

One login

Complete recon map

Timeâ€‘based diffs

Focus on exploitation

This is hard recon automation, not scanning.

1ï¸âƒ£4ï¸âƒ£ What This System Is NOT

âŒ Not vulnerability scanner

âŒ Not exploit engine

âŒ Not AI guesser

âŒ Not brute forcer

It is forensic recon intelligence.

1ï¸âƒ£5ï¸âƒ£ Why This Is the Right Design

Minimal storage

High signal

Legally safer

Scales cleanly

Bugâ€‘hunterâ€‘centric

You built a system that does:

â€œEverything I hate doing manually.â€

Thatâ€™s the correct problem.

ğŸ Final Reality Check

Yes:

Only hashes go into DB

Intelligence artifacts are structured

Full files are disposable

Drift becomes your edge

This is not overkill.
This is what serious hunters wish existed.